# -*- coding: utf-8 -*-
"""kaggle - KNN

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a224Inhmzm8TLqu8Z5YiFIMDqSDIM2yN
"""

! pip install kaggle

from google.colab import drive
drive.mount('/content/drive')

! mkdir -pv ~/.kaggle

! cp /content/drive/MyDrive/Colab\ Notebooks/kaggle.json ~/.kaggle/kaggle.json

! chmod 600 ~/.kaggle/kaggle.json

! kaggle competitions download air-heart-disease

! kaggle datasets download ashishsaxena2209/animal-image-datasetdog-cat-and-panda

! unzip animal-image-datasetdog-cat-and-panda.zip

import shutil
shutil.rmtree('/content/animals/animals', ignore_errors=True)
shutil.rmtree('/content/animals/images', ignore_errors=True)

import cv2
import numpy as np
import os

class SimplePreprocessor:
	def __init__(self, width, height, inter=cv2.INTER_AREA):
		# store the target image width, height, and interpolation
		# method used when resizing
		self.width = width
		self.height = height
		self.inter = inter

	def preprocess(self, image):
		# resize the image to a fixed size, ignoring the aspect ratio
		return cv2.resize(image, (self.width, self.height), interpolation=self.inter)

class SimpleDatasetLoader:
	def __init__(self, preprocessors=None):
		# store the image preprocessor
		self.preprocessors = preprocessors
		# if the preprocessors are None, initialize them as an empty list
		if self.preprocessors is None:
			self.preprocessors = []

	def load(self, imagePaths, verbose=-1):
		#initialize the list of features and labels
		data = []
		labels = []

		# loop over the input images
		for (i, imagePath) in enumerate(imagePaths):
			# load the image and extract the class label assuming
				# that our path has the following format:
					# /path/to/dataset/{class}/{image}.jpg
			image = cv2.imread(imagePath)
			label = imagePath.split(os.path.sep)[-2]

			#check to see if our preprocessors are not none
			if self.preprocessors is not None:
				# loop over the preprocessors and apply each to the image.
				for p in self.preprocessors:
					image = p.preprocess(image)

			# treat our processed image as a "feature vector"
			#by updateing the data list followed by the labels
			data.append(image)
			labels.append(label)

			# show an update every 'verbose' images
			if verbose>0 and i>0 and (i+1) % verbose == 0:
				print("[INFO] processed {}/{}".format(i+1, len(imagePaths)))

		# return a tuple of the data and labels
		return (np.array(data), np.array(labels))

from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from imutils import paths

# grab the list of images that we'll be describing
print("[INFO] loading images...")
imagePaths = list(paths.list_images("animals"))

# initialize the image preprocessor, load the dataset from disk, and reshape the data matrix
sp = SimplePreprocessor(32, 32)
sdl = SimpleDatasetLoader(preprocessors=[sp])
(data, labels) = sdl.load(imagePaths, verbose=500)
data = data.reshape((data.shape[0], 3072))

# show some information on memory consumption of the images
print("[INFO] features matrix: {:.1f}MB".format(data.nbytes / (1024 *1000.0)))

# encode the labels as integers
le = LabelEncoder()
labels = le.fit_transform(labels)

# partition the data into training and testing splits using 75% of the data for training and the remaining 25% for testing
(trainX, testX, trainY, testY) = train_test_split(data, labels, test_size = 0.25, random_state=42)

print("[INFO] 'training' k-NN classifier...")
model = KNeighborsClassifier(n_neighbors=3, n_jobs=-1)
model.fit(trainX, trainY)

print("[INFO] evaluating k-NN classifier...")
print(classification_report(testY, model.predict(testX), target_names=le.classes_))

print("Predito: ", model.predict(testX[0:1]))
print("Esperando: ",testY[0])

predito = model.predict(testX)

print(predito[0:11])
print(testY[0:11])