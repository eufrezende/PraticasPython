# -*- coding: utf-8 -*-
"""Constraint Satisfaction Problems (CSP)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1742JbjQnouoIzvm_no1x1JOmZAU3R8AO
"""

class CSP:
    def __init__(self, variables, domains, constraints):
        # Inicializa a instância da classe CSP com as variáveis, domínios e restrições.
        self.variables = variables  # Lista de variáveis
        self.domains = domains      # Dicionário de domínios das variáveis
        self.constraints = constraints  # Dicionário de restrições
        self.solution = None  # Armazenará a solução do problema

    def solve(self):
        # Método principal para resolver o CSP.
        assignment = {}  # Inicializa um dicionário de atribuições vazio.
        self.solution = self.backtrack(assignment)  # Chama a função de backtrack.
        return self.solution

    def backtrack(self, assignment):
        # Algoritmo de backtrack para encontrar a solução do CSP.
        if len(assignment) == len(self.variables):
            return assignment  # Se todas as variáveis estiverem atribuídas, retorna a solução.

        var = self.select_unassigned_variable(assignment)  # Seleciona uma variável não atribuída.
        for value in self.order_domain_values(var, assignment):
            # Itera sobre os valores do domínio da variável selecionada.
            if self.is_consistent(var, value, assignment):
                # Verifica se a atribuição é consistente com as restrições existentes.
                assignment[var] = value  # Atribui o valor à variável.
                result = self.backtrack(assignment)  # Chama recursivamente o backtrack.
                if result is not None:
                    return result  # Se uma solução foi encontrada, retorna-a.
                del assignment[var]  # Remove a atribuição se não levou a uma solução.

        return None  # Retorna None se não há solução.

    def select_unassigned_variable(self, assignment):
        # Seleciona uma variável não atribuída para ser atribuída a seguir.
        unassigned_vars = [var for var in self.variables if var not in assignment]
        return min(unassigned_vars, key=lambda var: len(self.domains[var]))

    def order_domain_values(self, var, assignment):
        # Determina a ordem em que os valores do domínio da variável são considerados.
        return self.domains[var]  # Neste caso, a ordem é a ordem original do domínio.

    def is_consistent(self, var, value, assignment):
        # Verifica se a atribuição é consistente com as restrições existentes.
        for constraint_var in self.constraints[var]:
            if constraint_var in assignment and assignment[constraint_var] == value:
                return False  # Se a restrição for violada, retorna False.
        return True  # Caso contrário, a atribuição é consistente.

# Fim da classe CSP

# Define um tabuleiro de sudoku representado como uma matriz 9x9, onde 0 indica células vazias.
puzzle = [
    [5, 3, 0, 0, 7, 0, 0, 0, 0],
    [6, 0, 0, 1, 9, 5, 0, 0, 0],
    [0, 9, 8, 0, 0, 0, 0, 6, 0],
    [8, 0, 0, 0, 6, 0, 0, 0, 3],
    [4, 0, 0, 8, 0, 3, 0, 0, 1],
    [7, 0, 0, 0, 2, 0, 0, 0, 6],
    [0, 6, 0, 0, 0, 0, 2, 8, 0],
    [0, 0, 0, 4, 1, 9, 0, 0, 5],
    [0, 0, 0, 0, 8, 0, 0, 0, 0]
]

# Define uma função para imprimir o tabuleiro de sudoku.
def print_sudoku(puzzle):
    for i in range(9):
        if i % 3 == 0 and i != 0:
            print("- - - - - - - - - - - ")  # Linha horizontal separando os blocos.
        for j in range(9):
            if j % 3 == 0 and j != 0:
                print(" | ", end="")  # Linha vertical separando as células do bloco.
            print(puzzle[i][j], end=" ")  # Imprime o valor da célula.
        print()

# Chama a função para imprimir o tabuleiro de sudoku.
print_sudoku(puzzle)

# Cria uma lista chamada "variables" que representa todas as variáveis em um problema relacionado ao tabuleiro do Sudoku.
# O problema é modelado como um tabuleiro 9x9, onde cada célula é uma variável que precisa ser atribuída com um valor.
variables = [(i, j) for i in range(9) for j in range(9)]

# Imprime a lista de variáveis.
print(variables)

# Cria um dicionário chamado "Domains" que representa os domínios das variáveis em um problema de Sudoku.
# Os domínios são definidos como conjuntos de números de 1 a 9 para variáveis vazias no tabuleiro.
# Se a variável já possui um valor no tabuleiro, seu domínio é definido como um conjunto com esse valor único.
Domains = {var: set(range(1, 10)) if puzzle[var[0]][var[1]] == 0
						else {puzzle[var[0]][var[1]]} for var in variables}

# Imprime o dicionário de domínios.
print(Domains)

# Define uma função chamada "add_constraint" para adicionar restrições a uma variável no problema do Sudoku.
def add_constraint(var):
    constraints[var] = []  # Inicializa a lista de restrições para a variável var como vazia.

    # Adiciona restrições relacionadas às linhas e colunas da variável.
    for i in range(9):
        if i != var[0]:
            constraints[var].append((i, var[1]))  # Adiciona a restrição (i, var[1]) para todas as linhas, exceto a da variável.
        if i != var[1]:
            constraints[var].append((var[0], i))  # Adiciona a restrição (var[0], i) para todas as colunas, exceto a da variável.

    # Determina a sub-grade 3x3 em que a variável está localizada.
    sub_i, sub_j = var[0] // 3, var[1] // 3

    # Adiciona restrições relacionadas à sub-grade.
    for i in range(sub_i * 3, (sub_i + 1) * 3):
        for j in range(sub_j * 3, (sub_j + 1) * 3):
            if (i, j) != var:
                constraints[var].append((i, j))  # Adiciona a restrição (i, j) para todas as células na mesma sub-grade, exceto a da variável.

# Inicializa um dicionário vazio chamado "constraints" para armazenar as restrições das variáveis.
constraints = {}

# Itera sobre todas as células do tabuleiro de Sudoku e chama a função "add_constraint" para cada variável.
for i in range(9):
    for j in range(9):
        add_constraint((i, j))  # Adiciona as restrições para a variável (i, j).

# Imprime o dicionário "constraints", que contém as restrições para todas as variáveis no problema do Sudoku.
print(constraints)

# Cria uma instância da classe CSP com as variáveis, domínios e restrições definidas anteriormente.
csp = CSP(variables, Domains, constraints)

# Chama o método "solve" na instância CSP para resolver o problema.
sol = csp.solve()

# Inicializa uma matriz vazia chamada "solution" para armazenar a solução do Sudoku.
solution = [[0 for i in range(9)] for i in range(9)]

# Preenche a matriz "solution" com os valores da solução encontrada.
for i, j in sol:
    solution[i][j] = sol[i, j]

# Imprime o tabuleiro de Sudoku da solução.
print_sudoku(solution)

# Definição do quebra-cabeça Sudoku como uma matriz 9x9, onde 0 indica células vazias.
puzzle = [[5, 3, 0, 0, 7, 0, 0, 0, 0],
          [6, 0, 0, 1, 9, 5, 0, 0, 0],
          [0, 9, 8, 0, 0, 0, 0, 6, 0],
          [8, 0, 0, 0, 6, 0, 0, 0, 3],
          [4, 0, 0, 8, 0, 3, 0, 0, 1],
          [7, 0, 0, 0, 2, 0, 0, 0, 6],
          [0, 6, 0, 0, 0, 0, 2, 8, 0],
          [0, 0, 0, 4, 1, 9, 0, 0, 5],
          [0, 0, 0, 0, 8, 0, 0, 0, 0]]

# Função para imprimir o quebra-cabeça Sudoku.
def print_sudoku(puzzle):
    for i in range(9):
        if i % 3 == 0 and i != 0:
            print("- - - - - - - - - - - ")
        for j in range(9):
            if j % 3 == 0 and j != 0:
                print(" | ", end="")
            print(puzzle[i][j], end=" ")
        print()

print_sudoku(puzzle)

# Definição da classe CSP (Constraint Satisfaction Problem) para resolver o Sudoku.
class CSP:
    def __init__(self, variables, Domains, constraints):
        # Inicializa a classe CSP com variáveis, domínios e restrições.
        self.variables = variables
        self.domains = Domains
        self.constraints = constraints
        self.solution = None

    def solve(self):
        # Método para resolver o problema usando backtrack.
        assignment = {}
        self.solution = self.backtrack(assignment)
        return self.solution

    def backtrack(self, assignment):
        # Algoritmo de backtrack para encontrar a solução do Sudoku.
        if len(assignment) == len(self.variables):
            return assignment

        var = self.select_unassigned_variable(assignment)
        for value in self.order_domain_values(var, assignment):
            if self.is_consistent(var, value, assignment):
                assignment[var] = value
                result = self.backtrack(assignment)
                if result is not None:
                    return result
                del assignment[var]
        return None

    def select_unassigned_variable(self, assignment):
        # Seleciona uma variável não atribuída para ser atribuída a seguir.
        unassigned_vars = [var for var in self.variables if var not in assignment]
        return min(unassigned_vars, key=lambda var: len(self.domains[var]))

    def order_domain_values(self, var, assignment):
        return self.domains[var]

    def is_consistent(self, var, value, assignment):
        for constraint_var in self.constraints[var]:
            if constraint_var in assignment and assignment[constraint_var] == value:
                return False
        return True

# Variáveis
variables = [(i, j) for i in range(9) for j in range(9)]
# Domínios
Domains = {var: set(range(1, 10)) if puzzle[var[0]][var[1]] == 0
           else {puzzle[var[0]][var[1]]} for var in variables}

# Adiciona restrições ao CSP para cada variável no tabuleiro do Sudoku.
def add_constraint(var):
    constraints[var] = []
    for i in range(9):
        if i != var[0]:
            constraints[var].append((i, var[1]))
        if i != var[1]:
            constraints[var].append((var[0], i))
    sub_i, sub_j = var[0] // 3, var[1] // 3
    for i in range(sub_i * 3, (sub_i + 1) * 3):
        for j in range(sub_j * 3, (sub_j + 1) * 3):
            if (i, j) != var:
                constraints[var].append((i, j))

# Dicionário de restrições
constraints = {}
for i in range(9):
    for j in range(9):
        add_constraint((i, j))

# Imprime o quebra-cabeça Sudoku e, em seguida, a solução encontrada.
print('*' * 7, 'Solution', '*' * 7)
csp = CSP(variables, Domains, constraints)
sol = csp.solve()

solution = [[0 for i in range(9)] for i in range(9)]
for i, j in sol:
    solution[i][j] = sol[i, j]

print_sudoku(solution)