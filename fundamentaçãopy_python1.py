# -*- coding: utf-8 -*-
"""FundamentaÃ§Ã£oPY_Python1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gMF8tjV_7Wjqb5cKcy3pMLKOMCxwTCtp

# Entendendo o Coolab - FormataÃ§Ã£o de Texto

## FormataÃ§Ã£o de texto com MARKDOWN

> https://support.zendesk.com/hc/pt-br/articles/4408846544922-Formata%C3%A7%C3%A3o-de-texto-com-Markdown

## FormataÃ§Ã£o de texto

**negrito**

*itÃ¡lico*

\_Sublinhado\_

~rasurado~

`monoespaÃ§ado`

### Ã‰ uma linguagem para produzir documentos tÃ©cnicos (LateX)

$x^2$

$\sqrt{2}$

$\frac{2}{3}$

a $\sqrt{9}$ Ã© 3.

## Listas

* item 1
* item 2
* item 3

ou

1. item 1
2. item 2
3. item 3

# CodificaÃ§Ã£o
"""

!pwd

!ls -l #Puxa os documentos na pasta /content com os dados de cada um

!mkdir ifgoiano  #Criar novo diretÃ³rio

"""#Fundamentos de python

* O analisador python divide o cÃ³digo em token (linhas lÃ³gicas).
* O agrupamento desses tokens formam coleÃ§Ãµes e tipos.

## Tipos bÃ¡sciso em Python
* Em alto nÃ­vel, os tipos predefinos sÃ£o numÃ©ricos (booleanos, inteiros e float), suquÃªncias (Strings), mapeamentos, classes, instÃ¢ncias e exceÃ§Ãµes.
> Tipos bÃ¡sicos
>* type(data)
>* type(None) Ã© um tipo sem valor de retorno

##DeclaraÃ§Ã£o/InstruÃ§Ã£o
* cada instruÃ§Ã£o Ã© uma aÃ§Ã£o
* uma expressÃ£o em python Ã© uma parte do cÃ³digo que avalia um valor (ou None)
* **tudo em Python Ã© objeto**
> *InstruÃ§Ãµes*:
> * *assert(" ")*: tem uma expressÃ£o como argumento e garante que o resultado Ã© True, se estiver vazia retorna False
> * *=* : aponta para uma parte dos dados
> * *pass*: espaÃ§o reservado que nÃ£o possui aÃ§Ã£o em si. Usada para esquematizar o design do cÃ³digo.
> * *del*: apaga algo do programa em execuÃ§Ã£o

# Listas e Tuplas
* A lista Ã© mutÃ¡vel, mas a tupla nÃ£o.
* A lista usa mais memÃ³ria
* A mudanÃ§a de uma tupla implica na criaÃ§Ã£o de uma nova tupla.
1. sintaxe de Lista: **Colchetes** ==> contrutor **list()**
2. sintaxe Tupla: parÃªnteses ==> contrutor **tuple()**

* MÃ©todo **pop()** remove o Ãºltimo item.
* MÃ©todo **extend()** adiciona uma lista a outra lista
* MÃ©todo **sort()** ordena uma lista em ordem crescente
* MÃ©todo **reverse()** inverte a posiÃ§Ã£o dos itens da lista
"""

#Listas e Tuplas

lista3 = list(range(1,4))
print(lista3)

lista4 = list()
print(lista4)

tupla = 1,2,3
print(tupla)

tupla2=(1,)
print(tupla2)

"""# String

* (f-string)

> Quando a String Ã© maior de uma linha uisa-se trÃŠs aspas duplas no inÃ­cio e no fim.

* MÃ©todo **capitalize()** coloca o primeiro caractere da String em maiusculo
* MÃ©todo **lower()** coloca todas as letras em minÃºsuclo
* MÃ©todo **upper()** todas as letras em maiÃºsculo
* MÃ©todo **swapcase()** inverte a caixa de cada caractere
* MÃ©todo **title()** coloca a primeira letra em maÃ­sculo de todas as palavras da String

1. ^ => inÃ­cio de linha
2. $ => final de linha
3. * => qualquer caractere


"""

#Strings

frutas1 = ["abacaxi", "morango"]
frutas2 = ["laranja"]
frutas1.extend(frutas2)
print(frutas1)

heroi = "homem Aranha"
letras = list(heroi)
letras.sort()
print(letras)


heroi = "homem Aranha"
letras = list(heroi)
letras.reverse()
print(letras)

"""# Intervalos

* FunÃ§Ã£o **range()**

"""

#Intervalos

x = list(range(10))
print(x)

x = list(range(0,10))
print(x)

x=list(range(0,10,-2))
print(x)

"""# DicionÃ¡rios

* armazena os dados como pares de chave/valor

* Sintaxe de chaves {} => construtor **dict()**
* **get()** passando a chave como argumento
* funÃ§Ã£o **del()** e o argumento o nome do dicionÃ¡rio com a chave entre colchetes
* mÃ©todo **values()** retorna um object dict_values com os valores
* mÃ©todo **items()** retorna um objeto dict_items com os pares chave/valor
* **len()** exibe o comprimento do objeto
* **reversed()** exibe o objeto em ordem inversa como argumento da funÃ§Ã£o **list()**
"""

pessoa = {'nome':'Peter', 'altura':1.72, 'peso':63}
print(pessoa)

print(pessoa.get('idade'))
pessoa['idade']= +30 #adicionando ao dicionÃ¡rio
print(pessoa.get('idade'))

del(pessoa['altura'])
print(pessoa)

"""# ReferÃªncias complementares:
* https://www.ic.unicamp.br/~wainer/cursos/1s2020/102/aula09.html

#Aprendizado de mÃ¡quina

- Consistem em deixar um computador encontrar um caminho para esolver um problema usando dados.
- ProgramaÃ§Ã£o tradicionar, o programador define o cÃ³digo para resolver um problema.
- As bibliotecas implementam algoritmos usados apra criar e treinar os modelos de aprendizado de mÃ¡quina.
- Os modelos tÃªm vÃ¡rios usos, dependendo do tipo de problema.
- HÃ¡ modelos usados apra prever valores futuros e outros apra classificar dados em grupos ou categorias.

##Bibliotecas

- **TensorFlow**: resolve problemas usando aprendizado profundo. Define camadas para transformaÃ§Ã£o dos dados.
- **Keras**: fonte apra trabalhar com TensorFlow
- **PyTorch**: usa GPUs para resolver problemas de aprendizado profundo.
- **Scikit-Learn**: se baseia no Numpy e SciPy. Tem classes para a maioria dos algoritmos tradicionais.

### Aprendizado nÃ£o Supervisionado:
- Envolve descobrir insights sobre os dados sem resultados preexistentes para testar.
- Costuma identificar padrÃµes com base nas caracterÃ­sticas dos dados sem usar qualquer entrada dos cientistas de dados.

### Aprendizado Supervisionado
- Envolve usar dados conhecidos apra treinar e testar um modelo.
- As estapas para treinar um modelo supervisionado sÃ£o:
> 1. Tranformar os dados
> 2. Separar os dados de teste
> 3. Treinar o modelo
> 4. Testar a precisÃ£o

#Funcionamento do Aprendizado de MÃ¡quina

###Tipos de dados
* Dados numÃ©ricos: sÃ£o dados quantitativos, medida de algo. A forma mais comum de representar as quantidades sÃ£o com valores numÃ©ricos.
* Dados categÃ³ricos:
* Testos
* Data e Hora
* Imagens

##TransformaÃ§Ã£o de dados
> O Scikit-learn inclui muitos transformadores, inslucive transformadores para:
* Limpeza de dados (prÃ©-processamento)
* ExtraÃ§Ã£o de features (caracterÃ­sticas)
* reduÃ§Ã£o de dimensionalidade
* ExpansÃ£o (aproximar o kernel)

Uma das transformaÃ§Ãµes mais importantes para se aplicar nos dados Ã© o ***feature scaling*** (escalonamento de caracterÃ­sticas).
Os algoritmos de aprendizado de mÃ¡quina nÃ£o funconam bem com atributos (campos) com escalas diferentes, salvo algumas exceÃ§Ãµes.

Os transformadores do Scikit-learn sÃ£o representados por classe (O.O) e normalmente usam os mÃ©todos:
> .fit(): para determinar a transformaÃ§Ã£o \\
> .transform(): para modificar os dados. \\
> A forma mais comum dos atributos obterem a mesma escala Ã© com: **MinMaxScaling** e **Standardization**

### MinMaxScaling
> TambÃ©m conhecido como "normalizaÃ§Ã£o" transforam os valores para um intervalo definido, entre 0 e 1 por padrÃ£o, ou seja, rescalar atravÃ©s do transformafor **MinMaxScaler** (minMax=MinMaxScaler()). \\
> O intervalo pode ser alterado para -1 e 1 com o hiperparÃ¢metro **feature_range** (minMax=MinMaxScaler(feature_range=(-1, 1)))

A transformaÃ§Ã£o segue a fÃ³rmula: **y=(x-min)/(max-min)** \\
onde: **x** Ã© a entrada (valor da coluna); **y** Ã© o dado em uma escala; **min** e **max** sÃ£o valores mÃ­nimo e mÃ¡ximo da coluna.

>seu uso Ã© recomendado para otimizar desempenho de algoritmos de modelagem preditiva, redes neurais que esperam entrada dentro do intervalo de 0 e 1, etapa de prÃ© processamento com muitos algoritmos de aprendizado de mÃ¡quina.
"""

#1. Utilize o exemplo de Min-Max Scalling e defina um intervalo de -1 e 1. Lembre-se que por padrÃ£o Ã© 0 e 1. Pesquise como alterar.

import numpy as np
from sklearn.preprocessing import MinMaxScaler

data = np.array ([[10, 34, 4],
                 [90, 2, 0],
                 [78, -12, 16],
                 [23, 45, 4]])
data
minMax=MinMaxScaler(feature_range=(-1, 1))
scaler=minMax.fit(data)
scaler.transform(data)

"""###Standardization (PadronizaÃ§Ã£o)

> tambÃ©m conhecido como normalizaÃ§Ã£o transofmra o atributo para se aproximar de uma "distribuiÃ§Ã£o normal" e que tenha uma mÃ©dia de 0 e um desvio padrÃ£o de 1, atravÃ©s do transofmrador **StandardScaler**.

O standard transforma valores conforme a equaÃ§Ã£o: **y=(x-m)/ðœƒ** \\
onde: **x** Ã© a entrada(valor d euma coluna); **y** Ã© dado padronizado; **m** Ã© a mÃ©dia, **ðœƒ** Ã© o desvio padrÃ£o.

### Separando os Dados de Teste

> * Um dos problemas encontrados na hora de treinar um modelo (classificador) Ã© o
sobreajuste. \\
> * No **sobreajuste** (overfitting) o modelo Ã© capaz de prever com perfeiÃ§Ã£o (100%) os dados usados para treino, mas tem baixo desempenho ao prever os dados de teste. \\
> * Pode-se dizer que o modelo memorizou os dados durante o teste. \\
>  (*Ã© quando o modelo nÃ£o aprende, ele decora*)
> * ao contrÃ¡rio do **sobreajuste**, tem a generalizaÃ§Ã£o em excesso ou superajuste (**unferfitting**) onde o modelo tem uma baixa taxa de acerto durante o treinamento. \\
> * essa situaÃ§Ã£o pode ocorrer quando os dados de treinamento sÃ£o pouco representativos (poucas caracterÃ­sticas) ou o modelo usado Ã© simples e nÃ£o consegue identificar padrÃµes.
>* **o ponto ideal Ã© o equilÃ­brio entre overfitting e underfitting**.
> * **AcurÃ¡cia x PrecisÃ£o** \\

Em conjuntos de dados geralmente se divide em 70-80% para treinamento e 30-20% para testes. \\
* No Scikit-learn hÃ¡ diversos mÃ©todos para divisÃ£o de dados.
Para se treinar um modelo Ã© necessÃ¡rio um conjunto de dados, com grande nÃºmero de dados (exemplos) rotulados.
> Fonte online: UCI Machine Lerarning https://archive.ics.uci.edu/

# Linguagem natural

> texto.
"""