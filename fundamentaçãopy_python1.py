# -*- coding: utf-8 -*-
"""FundamentaçãoPY_Python1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gMF8tjV_7Wjqb5cKcy3pMLKOMCxwTCtp

# Entendendo o Coolab - Formatação de Texto

## Formatação de texto com MARKDOWN

> https://support.zendesk.com/hc/pt-br/articles/4408846544922-Formata%C3%A7%C3%A3o-de-texto-com-Markdown

## Formatação de texto

**negrito**

*itálico*

\_Sublinhado\_

~rasurado~

`monoespaçado`

### É uma linguagem para produzir documentos técnicos (LateX)

$x^2$

$\sqrt{2}$

$\frac{2}{3}$

a $\sqrt{9}$ é 3.

## Listas

* item 1
* item 2
* item 3

ou

1. item 1
2. item 2
3. item 3

# Codificação
"""

!pwd

!ls -l #Puxa os documentos na pasta /content com os dados de cada um

!mkdir ifgoiano  #Criar novo diretório

"""#Fundamentos de python

* O analisador python divide o código em token (linhas lógicas).
* O agrupamento desses tokens formam coleções e tipos.

## Tipos básciso em Python
* Em alto nível, os tipos predefinos são numéricos (booleanos, inteiros e float), suquências (Strings), mapeamentos, classes, instâncias e exceções.
> Tipos básicos
>* type(data)
>* type(None) é um tipo sem valor de retorno

##Declaração/Instrução
* cada instrução é uma ação
* uma expressão em python é uma parte do código que avalia um valor (ou None)
* **tudo em Python é objeto**
> *Instruções*:
> * *assert(" ")*: tem uma expressão como argumento e garante que o resultado é True, se estiver vazia retorna False
> * *=* : aponta para uma parte dos dados
> * *pass*: espaço reservado que não possui ação em si. Usada para esquematizar o design do código.
> * *del*: apaga algo do programa em execução

# Listas e Tuplas
* A lista é mutável, mas a tupla não.
* A lista usa mais memória
* A mudança de uma tupla implica na criação de uma nova tupla.
1. sintaxe de Lista: **Colchetes** ==> contrutor **list()**
2. sintaxe Tupla: parênteses ==> contrutor **tuple()**

* Método **pop()** remove o último item.
* Método **extend()** adiciona uma lista a outra lista
* Método **sort()** ordena uma lista em ordem crescente
* Método **reverse()** inverte a posição dos itens da lista
"""

#Listas e Tuplas

lista3 = list(range(1,4))
print(lista3)

lista4 = list()
print(lista4)

tupla = 1,2,3
print(tupla)

tupla2=(1,)
print(tupla2)

"""# String

* (f-string)

> Quando a String é maior de uma linha uisa-se trÊs aspas duplas no início e no fim.

* Método **capitalize()** coloca o primeiro caractere da String em maiusculo
* Método **lower()** coloca todas as letras em minúsuclo
* Método **upper()** todas as letras em maiúsculo
* Método **swapcase()** inverte a caixa de cada caractere
* Método **title()** coloca a primeira letra em maísculo de todas as palavras da String

1. ^ => início de linha
2. $ => final de linha
3. * => qualquer caractere


"""

#Strings

frutas1 = ["abacaxi", "morango"]
frutas2 = ["laranja"]
frutas1.extend(frutas2)
print(frutas1)

heroi = "homem Aranha"
letras = list(heroi)
letras.sort()
print(letras)


heroi = "homem Aranha"
letras = list(heroi)
letras.reverse()
print(letras)

"""# Intervalos

* Função **range()**

"""

#Intervalos

x = list(range(10))
print(x)

x = list(range(0,10))
print(x)

x=list(range(0,10,-2))
print(x)

"""# Dicionários

* armazena os dados como pares de chave/valor

* Sintaxe de chaves {} => construtor **dict()**
* **get()** passando a chave como argumento
* função **del()** e o argumento o nome do dicionário com a chave entre colchetes
* método **values()** retorna um object dict_values com os valores
* método **items()** retorna um objeto dict_items com os pares chave/valor
* **len()** exibe o comprimento do objeto
* **reversed()** exibe o objeto em ordem inversa como argumento da função **list()**
"""

pessoa = {'nome':'Peter', 'altura':1.72, 'peso':63}
print(pessoa)

print(pessoa.get('idade'))
pessoa['idade']= +30 #adicionando ao dicionário
print(pessoa.get('idade'))

del(pessoa['altura'])
print(pessoa)

"""# Referências complementares:
* https://www.ic.unicamp.br/~wainer/cursos/1s2020/102/aula09.html

#Aprendizado de máquina

- Consistem em deixar um computador encontrar um caminho para esolver um problema usando dados.
- Programação tradicionar, o programador define o código para resolver um problema.
- As bibliotecas implementam algoritmos usados apra criar e treinar os modelos de aprendizado de máquina.
- Os modelos têm vários usos, dependendo do tipo de problema.
- Há modelos usados apra prever valores futuros e outros apra classificar dados em grupos ou categorias.

##Bibliotecas

- **TensorFlow**: resolve problemas usando aprendizado profundo. Define camadas para transformação dos dados.
- **Keras**: fonte apra trabalhar com TensorFlow
- **PyTorch**: usa GPUs para resolver problemas de aprendizado profundo.
- **Scikit-Learn**: se baseia no Numpy e SciPy. Tem classes para a maioria dos algoritmos tradicionais.

### Aprendizado não Supervisionado:
- Envolve descobrir insights sobre os dados sem resultados preexistentes para testar.
- Costuma identificar padrões com base nas características dos dados sem usar qualquer entrada dos cientistas de dados.

### Aprendizado Supervisionado
- Envolve usar dados conhecidos apra treinar e testar um modelo.
- As estapas para treinar um modelo supervisionado são:
> 1. Tranformar os dados
> 2. Separar os dados de teste
> 3. Treinar o modelo
> 4. Testar a precisão

#Funcionamento do Aprendizado de Máquina

###Tipos de dados
* Dados numéricos: são dados quantitativos, medida de algo. A forma mais comum de representar as quantidades são com valores numéricos.
* Dados categóricos:
* Testos
* Data e Hora
* Imagens

##Transformação de dados
> O Scikit-learn inclui muitos transformadores, inslucive transformadores para:
* Limpeza de dados (pré-processamento)
* Extração de features (características)
* redução de dimensionalidade
* Expansão (aproximar o kernel)

Uma das transformações mais importantes para se aplicar nos dados é o ***feature scaling*** (escalonamento de características).
Os algoritmos de aprendizado de máquina não funconam bem com atributos (campos) com escalas diferentes, salvo algumas exceções.

Os transformadores do Scikit-learn são representados por classe (O.O) e normalmente usam os métodos:
> .fit(): para determinar a transformação \\
> .transform(): para modificar os dados. \\
> A forma mais comum dos atributos obterem a mesma escala é com: **MinMaxScaling** e **Standardization**

### MinMaxScaling
> Também conhecido como "normalização" transforam os valores para um intervalo definido, entre 0 e 1 por padrão, ou seja, rescalar através do transformafor **MinMaxScaler** (minMax=MinMaxScaler()). \\
> O intervalo pode ser alterado para -1 e 1 com o hiperparâmetro **feature_range** (minMax=MinMaxScaler(feature_range=(-1, 1)))

A transformação segue a fórmula: **y=(x-min)/(max-min)** \\
onde: **x** é a entrada (valor da coluna); **y** é o dado em uma escala; **min** e **max** são valores mínimo e máximo da coluna.

>seu uso é recomendado para otimizar desempenho de algoritmos de modelagem preditiva, redes neurais que esperam entrada dentro do intervalo de 0 e 1, etapa de pré processamento com muitos algoritmos de aprendizado de máquina.
"""

#1. Utilize o exemplo de Min-Max Scalling e defina um intervalo de -1 e 1. Lembre-se que por padrão é 0 e 1. Pesquise como alterar.

import numpy as np
from sklearn.preprocessing import MinMaxScaler

data = np.array ([[10, 34, 4],
                 [90, 2, 0],
                 [78, -12, 16],
                 [23, 45, 4]])
data
minMax=MinMaxScaler(feature_range=(-1, 1))
scaler=minMax.fit(data)
scaler.transform(data)

"""###Standardization (Padronização)

> também conhecido como normalização transofmra o atributo para se aproximar de uma "distribuição normal" e que tenha uma média de 0 e um desvio padrão de 1, através do transofmrador **StandardScaler**.

O standard transforma valores conforme a equação: **y=(x-m)/𝜃** \\
onde: **x** é a entrada(valor d euma coluna); **y** é dado padronizado; **m** é a média, **𝜃** é o desvio padrão.

### Separando os Dados de Teste

> * Um dos problemas encontrados na hora de treinar um modelo (classificador) é o
sobreajuste. \\
> * No **sobreajuste** (overfitting) o modelo é capaz de prever com perfeição (100%) os dados usados para treino, mas tem baixo desempenho ao prever os dados de teste. \\
> * Pode-se dizer que o modelo memorizou os dados durante o teste. \\
>  (*é quando o modelo não aprende, ele decora*)
> * ao contrário do **sobreajuste**, tem a generalização em excesso ou superajuste (**unferfitting**) onde o modelo tem uma baixa taxa de acerto durante o treinamento. \\
> * essa situação pode ocorrer quando os dados de treinamento são pouco representativos (poucas características) ou o modelo usado é simples e não consegue identificar padrões.
>* **o ponto ideal é o equilíbrio entre overfitting e underfitting**.
> * **Acurácia x Precisão** \\

Em conjuntos de dados geralmente se divide em 70-80% para treinamento e 30-20% para testes. \\
* No Scikit-learn há diversos métodos para divisão de dados.
Para se treinar um modelo é necessário um conjunto de dados, com grande número de dados (exemplos) rotulados.
> Fonte online: UCI Machine Lerarning https://archive.ics.uci.edu/

# Linguagem natural

> texto.
"""