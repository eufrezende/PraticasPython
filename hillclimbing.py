# -*- coding: utf-8 -*-
"""HillClimbing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ioca53ffc7c7CVp9uQ0WAV1svBy1QUP1

### Qual o problema ?
- Maximizar o resultado da seguinte equação matemática![equacao.png](data:image/png;base64,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)

- Qual valor de X, resulta em um resultado maior ?
- Não temos a resposta exata, ou seja, na teoria não sabemos o quanto essa função pode ser maximizada, mas temos em mente que quanto maior melhor
- github: https://github.com/AlvaroCavalcante/algoritmos-busca

### Representação
- O domínio do problema se dá em um intervalo de [0, 1]
- X pode assumir qualquer valor dentro desse domínio

### Objetivo
- Maximizar o resultado da equação através do melhor valor possível de X.
- O melhor valor será definido por aquele que tiver o maior resultado final dentre todas as soluções encontradas

## Codificando
- Vamos começar com a importação das bibliotecas
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import random
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline

"""### Criação da função de custo / avaliação
- É basicamente o coração dos algoritmos de otimização
- A função de custo é onde a avaliação do algoritmo vai acontecer de fato
- Nesse caso a função de custo é dada simplesmente pelo resultado da equação que deve ser maximizado
"""

def funcao_custo(x):
    custo = 2 ** -2 * (x - 0.1 / 0.9) ** 2 * (math.sin(5 * math.pi * x))** 6
    return custo

"""### Função de plotar o gráfico
- Usado para plotar o gráfico com os resultados
"""

def plotar_busca(resultados):
    t = np.arange(0.0, len(resultados), 1)

    plt.figure(figsize=(12,8))
    plt.plot(t, resultados)
    plt.show()

"""### Função de get vizinhos
- Essa função é usada para pegar os vizinhos de cada dimensão da minha variável, no nosso caso temos uma única dimensão, que é a variável X
- Sendo assim vamos pegar os dois vizinhos possíveis do nosso X, considerando possíveis movimentos que ele pode fazer
- O vizinho nada mais é que uma perturbação no valor inicial, pode se um valor constante ou alguma outra formula, como a guasiana
"""

def get_vizinhos(solucao, aprendizado):
    vizinhos = []
    aprendizado = aprendizado / 10 if aprendizado >= 10 else 1
    constante = 0.005 / aprendizado
    vizinho_superior = solucao + constante if solucao + constante < 1 else solucao
    vizinho_inferior = solucao - constante if solucao - constante > 0 else solucao

    vizinhos.append(vizinho_superior)
    vizinhos.append(vizinho_inferior)
    return vizinhos

"""### Função get valor aleatório
- Função que vai garantir que meus valores aleatórios tenham um espaço mínimo entre eles.
- Essa função é usada pois o Hill Climbing depende de ser executado várias vezes para que ele inicie de diferentes pontos.
- Sem ela, esse inicialização pode acabar sendo muito próxima, fazendo com o que espaço de soluções não seja devidamente explorado
"""

def get_valor_aleatorio(espaco, x=0):
    inicio = random.random()
    valor = []

    for i in espaco:
        diferenca = i - inicio
        if diferenca > 0.05 or diferenca < -0.05:
            valor.append(diferenca)

    if len(valor) == len(espaco) or x > 300:
        return inicio
    else:
        return get_valor_aleatorio(espaco, x = x + 1)

"""### Hill Climbing
- Função que vai fazer o cálculo do algoritmo de subida da encosta
"""

def hill_climbing(funcao_custo, solucao_inicial):
    # random.seed(a=0)
    solucao = solucao_inicial
    custos = []
    count = 1
    parar_no_plato = 0

    while count <= 400:
        vizinhos = get_vizinhos(solucao, count)

        atual = funcao_custo(solucao)
        melhor = atual
        solucao_atual = solucao
        custos.append(atual)

        for i in range(len(vizinhos)):
            custo = funcao_custo(vizinhos[i])
            if custo >= melhor:
                parar_no_plato = parar_no_plato + 1 if custo == melhor else 0
                melhor = custo
                solucao = vizinhos[i]

        count += 1
        if melhor == atual and solucao_atual == solucao or parar_no_plato == 20:
            if parar_no_plato == 20: print('plato')
            break

    return solucao, custos

custos = []
solucao = []
espaco_solucao = []

for i in range(10):
    espaco_solucao.append(get_valor_aleatorio(espaco_solucao))

    solucao_subida_encosta = hill_climbing(funcao_custo, espaco_solucao[len(espaco_solucao) - 1])
    solucao.append(solucao_subida_encosta[0])
    custos.append(solucao_subida_encosta[1])

    if len(custos) > 1:
        if max(custos[1]) > max(custos[0]):
            custos.pop(0)
        else:
            custos.pop(1)

print('Valor X:', solucao_subida_encosta[0])
print('custos', solucao_subida_encosta[1])
plotar_busca(solucao_subida_encosta[1])

"""### Tentativas de otimização
- Código feito com objetivo de ajudar nosso algoritmo de busca
#### Parada no platô
- Caso nosso algoritmo tenha diversas interações sem gerar melhoria, ele da um break em sua execução
#### Redução da "taxa de aprendizado" de forma dinâmica
- Reduzir a "taxa de aprendizado"/perturbação nos nosso vizinhos, como forma de tentar evitar que o algoritmo perca um máximo/mínimo local/globa por conta de dar um "passo" muito grande
#### Exploração do espaço de características
- Garantir que os pontos gerados de forma aleatória estejam distantes uns dos outros para explorar um espaço maior

### Simulated annealing
Recozimento simulado é inspirado em um fenômeno da física, onde se esquenta um metal ou vidro até quase ele se liquefazer e depois se esfria devagar, para que os átomos percam a vibração aos poucos e o material fique rígido

- A diferença dele para o Hill Climbing é que ele tem uma probabilidade P de aceitar valores negativos
- Quanto mais no início do algoritmo, maior a sua chance de aceitar um valor negativo

### Probabilidade
- A probabilidade do simulated annealing é dada pela função exponencial exp(x)
- Nessa função, elevamos o número de euler ~2.7 à um valor de x.
- O X no nosso caso é o resultado da subtração entre o novo custo e o custo anterior divido pela temperatura: (x' - x) / T
- A temperatura vai diminuindo gradativamente, limitando nossas interações e garantindo que a probabilidade de se aceitar valores negativos também diminua
"""

def simulated_annealing(dominio, funcao_custo, temperatura = 10000.0, resfriamento = 0.95, passo = 1):
    # random.seed(a=0)
    solucao = random.random()
    custos = []
    count = 1
    parar_no_plato = 0

    while temperatura > 0.1:
        vizinhos = get_vizinhos(solucao, count)

        atual = funcao_custo(solucao)
        melhor = atual
        solucao_atual = solucao
        custos.append(atual)

        for i in range(len(vizinhos)):

            if parar_no_plato == 20:
                break

            custo = funcao_custo(vizinhos[i])
            probabilidade = pow(math.e, (-custo - melhor) / temperatura)

            if custo >= melhor or random.random() < probabilidade:
                parar_no_plato = parar_no_plato + 1 if custo == melhor else 0
                melhor = custo
                solucao = vizinhos[i]

        temperatura = temperatura * resfriamento

    return solucao, custos

solucao_tempera_simulada = simulated_annealing([0, 1], funcao_custo)
custo_tempera_simulada = funcao_custo(solucao_tempera_simulada[0])

print('Menor custo', custo_tempera_simulada)
plotar_busca(solucao_tempera_simulada[1])