# -*- coding: utf-8 -*-
"""Tutorial Reconhecimento de Face com OpenCV

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GFbSSLIVWku3K9ggExlTPzbWb6va3nlf

**Reprodução do Tutorial:**
[Reconhecimento de Face com OpenCV](https://pyimagesearch.com/2018/09/24/opencv-face-recognition/)

Alunos: Felipe Rezende e Mateus Elias
"""

# importe as bibliotecas necessárias
from imutils import paths
import numpy as np
import argparse
import imutils
import pickle
import cv2
import os

# carregue o detector de rostos serializado do disco
print("[INFO] loading face detector...")
protoPath = os.path.sep.join([args["detector"], "deploy.prototxt"])
modelPath = os.path.sep.join([args["detector"],
	"res10_300x300_ssd_iter_140000.caffemodel"])
detector = cv2.dnn.readNetFromCaffe(protoPath, modelPath)
# carregue o modelo de incorporação de rostos serializado do disco
print("[INFO] loading face recognizer...")
embedder = cv2.dnn.readNetFromTorch(args["embedding_model"])

# obtenha os caminhos para as imagens de entrada no conjunto de dados
print("[INFO] quantifying faces...")
imagePaths = list(paths.list_images(args["dataset"]))
# inicialize as listas de incorporações faciais extraídas e
# nomes correspondentes de pessoas
knownEmbeddings = []
knownNames = []
# inicialize o número total de rostos processados
total = 0

# loop sobre os caminhos das imagens
for (i, imagePath) in enumerate(imagePaths):
    # extraia o nome da pessoa do caminho da imagem
	print("[INFO] processing image {}/{}".format(i + 1,
		len(imagePaths)))
	name = imagePath.split(os.path.sep)[-2]
    # carregue a imagem, redimensione-a para ter uma largura de 600 pixels (mantendo
    # a proporção), e então obtenha as dimensões da imagem
	image = cv2.imread(imagePath)
	image = imutils.resize(image, width=600)
	(h, w) = image.shape[:2]

    # construa um blob a partir da imagem
	imageBlob = cv2.dnn.blobFromImage(
		cv2.resize(image, (300, 300)), 1.0, (300, 300),
		(104.0, 177.0, 123.0), swapRB=False, crop=False)
    # aplique o detector de rostos baseado em aprendizado profundo do OpenCV para localizar
    # rostos na imagem de entrada
    detector.setInput(imageBlob)
    detections = detector.forward()

    # certifique-se de que pelo menos um rosto foi encontrado
    if len(detections) > 0:
        # estamos assumindo que cada imagem tem apenas UM
        # rosto, portanto, encontre a caixa delimitadora com a maior probabilidade
        i = np.argmax(detections[0, 0, :, 2])
        confidence = detections[0, 0, i, 2]
        # certifique-se de que a detecção com a maior probabilidade também
        # atende ao nosso teste mínimo de probabilidade (ajudando a filtrar
        # detecções fracas)
        if confidence > 0.5:
            # calcule as coordenadas (x, y) da caixa delimitadora para
            # o rosto
            box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
            (startX, startY, endX, endY) = box.astype("int")
            # extraia a região de interesse do rosto e obtenha as dimensões da ROI
            face = image[startY:endY, startX:endX]
            (fH, fW) = face.shape[:2]
            # certifique-se de que a largura e altura do rosto são suficientemente grandes
            if fW > 20 and fH > 20:
                # construa um blob para a ROI do rosto, então passe o blob
                # através do nosso modelo de incorporação de rostos para obter a quantificação de 128-d
                faceBlob = cv2.dnn.blobFromImage(face, 1.0 / 255,
                    (96, 96), (0, 0, 0), swapRB=True, crop=False)
                embedder.setInput(faceBlob)
                vec = embedder.forward()
                # adicione o nome da pessoa + incorporação facial correspondente
                # às listas respectivas
                knownNames.append(name)
                knownEmbeddings.append(vec.flatten())
                total += 1

# grave as incorporações faciais + nomes no disco
print("[INFO] serializing {} encodings...".format(total))
data = {"embeddings": knownEmbeddings, "names": knownNames}
f = open(args["embeddings"], "wb")
f.write(pickle.dumps(data))
f.close()

from sklearn.preprocessing import LabelEncoder
from sklearn.svm import SVC
import argparse
import pickle

# carrega os embeddings faciais
print("[INFO] loading face embeddings...")
data = pickle.loads(open(args["embeddings"], "rb").read())

# codifica os rótulos
print("[INFO] encoding labels...")
le = LabelEncoder()
labels = le.fit_transform(data["names"])

# treina o modelo utilizado para aceitar os embeddings faciais de 128 dimensões e
# então realizar o reconhecimento facial real
print("[INFO] training model...")
recognizer = SVC(C=1.0, kernel="linear", probability=True)
recognizer.fit(data["embeddings"], labels)

# escreve o modelo de reconhecimento facial real no disco
f = open(args["recognizer"], "wb")
f.write(pickle.dumps(recognizer))
f.close()

# escreve o codificador de rótulos no disco
f = open(args["le"], "wb")
f.write(pickle.dumps(le))
f.close()

# importa os pacotes necessários
import numpy as np
import argparse
import imutils
import pickle
import cv2
import os
from google.colab.patches import cv2_imshow

# carrega nosso detector facial serializado do disco
print("[INFO] loading face detector...")
protoPath = os.path.sep.join([args["detector"], "deploy.prototxt"])
modelPath = os.path.sep.join([args["detector"],
	"res10_300x300_ssd_iter_140000.caffemodel"])
detector = cv2.dnn.readNetFromCaffe(protoPath, modelPath)

# carrega nosso modelo de incorporação facial serializado do disco
print("[INFO] loading face recognizer...")
embedder = cv2.dnn.readNetFromTorch(args["embedding_model"])

# carrega o modelo real de reconhecimento facial junto com o codificador de rótulos
recognizer = pickle.loads(open(args["recognizer"], "rb").read())
le = pickle.loads(open(args["le"], "rb").read())

# carrega a imagem, redimensiona-a para ter uma largura de 600 pixels (mantendo
# a proporção), e então obtém as dimensões da imagem
image = cv2.imread(args["image"])
image = imutils.resize(image, width=600)
(h, w) = image.shape[:2]

# constrói um blob a partir da imagem
imageBlob = cv2.dnn.blobFromImage(
	cv2.resize(image, (300, 300)), 1.0, (300, 300),
	(104.0, 177.0, 123.0), swapRB=False, crop=False)

# aplica o detector facial baseado em aprendizado profundo do OpenCV para localizar
# rostos na imagem de entrada
detector.setInput(imageBlob)
detections = detector.forward()

# loop sobre as detecções
for i in range(0, detections.shape[2]):
    # extrai a confiança (ou seja, probabilidade) associada à
    # previsão
    confidence = detections[0, 0, i, 2]

    # filtra detecções fracas
    if confidence > 0.9:

        # calcula as coordenadas (x, y) da caixa delimitadora para o
        # rosto
        box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
        (startX, startY, endX, endY) = box.astype("int")

        # extrai a região de interesse (ROI) do rosto
        face = image[startY:endY, startX:endX]
        (fH, fW) = face.shape[:2]

        # assegura que a largura e altura do rosto sejam suficientemente grandes
        if fW >= 20 and fH >= 20:
            # constrói um blob para a ROI do rosto, então passa o blob
            # através do nosso modelo de incorporação facial para obter a
            # quantificação de 128 dimensões do rosto
            faceBlob = cv2.dnn.blobFromImage(face, 1.0 / 255, (96, 96),
                                             (0, 0, 0), swapRB=True, crop=False)
            embedder.setInput(faceBlob)
            vec = embedder.forward()

            # realiza classificação para reconhecer o rosto
            preds = recognizer.predict_proba(vec)[0]
            j = np.argmax(preds)
            proba = preds[j]
            name = le.classes_[j]

            # desenha a caixa delimitadora do rosto junto com a
            # probabilidade associada
            text = "{}: {:.2f}%".format(name, proba * 100)
            y = startY - 10 if startY - 10 > 10 else startY + 10
            cv2.rectangle(image, (startX, startY), (endX, endY),
                          (0, 0, 255), 2)
            cv2.putText(image, text, (startX, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.45, (0, 0, 255), 2)

# mostra a imagem de saída
cv2_imshow(image)
cv2.waitKey(0)

#BONUS: Recognize faces in video streams
# importa os pacotes necessários
from imutils.video import VideoStream
from imutils.video import FPS
import numpy as np
import argparse
import imutils
import pickle
import time
import cv2
import os

# carrega nosso detector facial serializado do disco
print("[INFO] carregando detector facial...")
protoPath = os.path.sep.join([args["detector"], "deploy.prototxt"])
modelPath = os.path.sep.join([args["detector"],
	"res10_300x300_ssd_iter_140000.caffemodel"])
detector = cv2.dnn.readNetFromCaffe(protoPath, modelPath)

# carrega nosso modelo de incorporação facial serializado do disco
print("[INFO] carregando reconhecedor facial...")
embedder = cv2.dnn.readNetFromTorch(args["embedding_model"])

# carrega o modelo real de reconhecimento facial junto com o codificador de rótulos
recognizer = pickle.loads(open(args["recognizer"], "rb").read())
le = pickle.loads(open(args["le"], "rb").read())

# inicializa o fluxo de vídeo, permitindo que o sensor da câmera aqueça
print("[INFO] iniciando transmissão de vídeo...")
vs = VideoStream(src=0).start()
time.sleep(2.0)

# inicia o estimador de throughput de FPS
fps = FPS().start()

# loop sobre os quadros do fluxo de vídeo
while True:
	# obtém o quadro do fluxo de vídeo segmentado
	frame = vs.read()

	# redimensiona o quadro para ter uma largura de 600 pixels (mantendo
	# a proporção), e então obtém as dimensões da imagem
	frame = imutils.resize(frame, width=600)
	(h, w) = frame.shape[:2]

	# constrói um blob a partir da imagem
	imageBlob = cv2.dnn.blobFromImage(
		cv2.resize(frame, (300, 300)), 1.0, (300, 300),
		(104.0, 177.0, 123.0), swapRB=False, crop=False)

	# aplica o detector facial baseado em aprendizado profundo do OpenCV para localizar
	# rostos na imagem de entrada
	detector.setInput(imageBlob)
	detections = detector.forward()

	# loop sobre as detecções
	for i in range(0, detections.shape[2]):
		# extrai a confiança (ou seja, probabilidade) associada à
		# previsão
		confidence = detections[0, 0, i, 2]

		# filtra detecções fracas
		if confidence > args["confidence"]:
			# calcula as coordenadas (x, y) da caixa delimitadora para o
			# rosto
			box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
			(startX, startY, endX, endY) = box.astype("int")

			# extrai a região de interesse (ROI) do rosto
			face = frame[startY:endY, startX:endX]
			(fH, fW) = face.shape[:2]

			# assegura que a largura e altura do rosto sejam suficientemente grandes
			if fW < 20 or fH < 20:
				# constrói um blob para a ROI do rosto, então passa o blob
				# através do nosso modelo de incorporação facial para obter a
				# quantificação de 128 dimensões do rosto
				faceBlob = cv2.dnn.blobFromImage(face, 1.0 / 255,
					(96, 96), (0, 0, 0), swapRB=True, crop=False)
				embedder.setInput(faceBlob)
				vec = embedder.forward()

				# realiza classificação para reconhecer o rosto
				preds = recognizer.predict_proba(vec)[0]
				j = np.argmax(preds)
				proba = preds[j]
				name = le.classes_[j]

				# desenha a caixa delimitadora do rosto junto com a
				# probabilidade associada
				text = "{}: {:.2f}%".format(name, proba * 100)
				y = startY - 10 if startY - 10 > 10 else startY + 10
				cv2.rectangle(frame, (startX, startY), (endX, endY),
					(0, 0, 255), 2)
				cv2.putText(frame, text, (startX, y),
					cv2.FONT_HERSHEY_SIMPLEX, 0.45, (0, 0, 255), 2)

	# atualiza o contador de FPS
	fps.update()

	# mostra o quadro de saída
	cv2.imshow("Quadro", frame)
	key = cv2.waitKey(1) & 0xFF

	# se a tecla 'q' for pressionada, saia do loop
	if key == ord("q"):
		break

# para o cronômetro e exibe informações de FPS
fps.stop()
print("[INFO] tempo decorrido: {:.2f}".format(fps.elapsed()))
print("[INFO] FPS aproximado: {:.2f}".format(fps.fps()))

# faz a limpeza
cv2.destroyAllWindows()
vs.stop()