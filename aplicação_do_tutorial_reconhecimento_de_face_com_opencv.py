# -*- coding: utf-8 -*-
"""Aplicação do Tutorial Reconhecimento de Face com OpenCV

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iiTYilhXd7kEpYte9Qmvc4TGkyLEBZEe

**Reprodução do Tutorial:**
[Reconhecimento de Face com OpenCV](https://pyimagesearch.com/2018/09/24/opencv-face-recognition/)

Biblioteca celebridades kaggle

kaggle datasets download -d hereisburak/pins-face-recognition


Alunos: Felipe Rezende e Mateus Elias
"""

! pip install kaggle

from google.colab import drive
drive.mount('/content/drive')

! mkdir -pv ~/.kaggle

! cp /content/drive/MyDrive/Colab\ Notebooks/kaggle.json ~/.kaggle/kaggle.json

! chmod 600 ~/.kaggle/kaggle.json

! kaggle datasets download -d hereisburak/pins-face-recognition

! unzip pins-face-recognition.zip

#!git clone https://github.com/opencv/opencv.git
#!git clone https://github.com/anasbadawy/Face-Detection.git
!git clone https://github.com/fulviomascara/face-recognition-cnn.git

# importe as bibliotecas necessárias
from imutils import paths
import numpy as np
import argparse
import imutils
import pickle
import cv2
import os

# carregue o detector de rostos serializado do disco
print("[INFO] carregando detector de rostos...")
protoPath = os.path.join("/content/face-recognition-cnn/face_detection_model/deploy.prototxt")
modelPath = os.path.join("/content/face-recognition-cnn/face_detection_model/res10_300x300_ssd_iter_140000.caffemodel")
detector = cv2.dnn.readNetFromCaffe(protoPath, modelPath)
# carregue o modelo de incorporação de rostos serializado do disco
print("[INFO] carregando reconhecedor de rostos...")
embedder = cv2.dnn.readNetFromTorch("/content/face-recognition-cnn/openface_nn4.small2.v1.t7")

# obtenha os caminhos para as imagens de entrada no conjunto de dados
print("[INFO] quantificando rostos...")
imagePaths = list(paths.list_images("/content/105_classes_pins_dataset"))

# inicialize as listas de incorporações faciais extraídas e
# nomes correspondentes de pessoas
knownEmbeddings = []
knownNames = []
# inicialize o número total de rostos processados
total = 0

# loop sobre os caminhos das imagens
for (i, imagePath) in enumerate(imagePaths):
    # extraia o nome da pessoa do caminho da imagem
    print("[INFO] processando imagem {}/{}".format(i + 1,
        len(imagePaths)))
    name = imagePath.split(os.path.sep)[-2]
    # carregue a imagem, redimensione-a para ter uma largura de 600 pixels (mantendo
    # a proporção), e então obtenha as dimensões da imagem
    image = cv2.imread(imagePath)
    image = imutils.resize(image, width=600)
    (h, w) = image.shape[:2]

    # construa um blob a partir da imagem
    imageBlob = cv2.dnn.blobFromImage(
        cv2.resize(image, (300, 300)), 1.0, (300, 300),
        (104.0, 177.0, 123.0), swapRB=False, crop=False)
    # aplique o detector de rostos baseado em aprendizado profundo do OpenCV para localizar
    # rostos na imagem de entrada
    detector.setInput(imageBlob)
    detections = detector.forward()

    # certifique-se de que pelo menos um rosto foi encontrado
    if len(detections) > 0:
        # estamos assumindo que cada imagem tem apenas UM
        # rosto, portanto, encontre a caixa delimitadora com a maior probabilidade
        i = np.argmax(detections[0, 0, :, 2])
        confidence = detections[0, 0, i, 2]
        # certifique-se de que a detecção com a maior probabilidade também
        # atende ao nosso teste mínimo de probabilidade (ajudando a filtrar
        # detecções fracas)
        if confidence > 0.2:
            # calcule as coordenadas (x, y) da caixa delimitadora para
            # o rosto
            box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
            (startX, startY, endX, endY) = box.astype("int")
            # extraia a região de interesse do rosto e obtenha as dimensões da ROI
            face = image[startY:endY, startX:endX]
            (fH, fW) = face.shape[:2]
            # certifique-se de que a largura e altura do rosto são suficientemente grandes
            if fW > 20 and fH > 20:
                # construa um blob para a ROI do rosto, então passe o blob
                # através do nosso modelo de incorporação de rostos para obter a quantificação de 128-d
                faceBlob = cv2.dnn.blobFromImage(face, 1.0 / 255,
                    (96, 96), (0, 0, 0), swapRB=True, crop=False)
                embedder.setInput(faceBlob)
                vec = embedder.forward()
                # adicione o nome da pessoa + incorporação facial correspondente
                # às listas respectivas
                knownNames.append(name)
                knownEmbeddings.append(vec.flatten())
                total += 1

# grave as incorporações faciais + nomes no disco
print("[INFO] serializando {} incorporações...".format(total))
data = {"embeddings": knownEmbeddings, "names": knownNames}
f = open("/content/drive/MyDrive/Colab Notebooks/FaceOpenCV/embedding2.pickle", "wb")
f.write(pickle.dumps(data))
f.close()

from sklearn.preprocessing import LabelEncoder
from sklearn.svm import SVC
import argparse
import pickle

# carrega os embeddings faciais
print("[INFO] carregando embeddings faciais...")
data = pickle.loads(open("/content/drive/MyDrive/Colab Notebooks/FaceOpenCV/embedding2.pickle", "rb").read())

# codifica os rótulos
print("[INFO] codificando rótulos...")
le = LabelEncoder()
labels = le.fit_transform(data["names"])

# treina o modelo utilizado para aceitar os embeddings faciais de 128 dimensões e
# então realizar o reconhecimento facial real
print("[INFO] treinando modelo...")
recognizer = SVC(C=1.0, kernel="linear", probability=True)
recognizer.fit(data["embeddings"], labels)

# escreve o modelo de reconhecimento facial real no disco
f = open("/content/drive/MyDrive/Colab Notebooks/FaceOpenCV/embeddingRecognizer2.pickle", "wb")
f.write(pickle.dumps(recognizer))
f.close()

# escreve o codificador de rótulos no disco
f = open("/content/drive/MyDrive/Colab Notebooks/FaceOpenCV/le2.pickle", "wb")
f.write(pickle.dumps(le))
f.close()

# importa os pacotes necessários
import numpy as np
import argparse
import imutils
import pickle
import cv2
import os
from google.colab.patches import cv2_imshow

# carrega nosso detector facial serializado do disco
protoPath = os.path.join("/content/face-recognition-cnn/face_detection_model/deploy.prototxt")
modelPath = os.path.join("/content/face-recognition-cnn/face_detection_model/res10_300x300_ssd_iter_140000.caffemodel")
detector = cv2.dnn.readNetFromCaffe(protoPath, modelPath)

# carrega nosso modelo de incorporação facial serializado do disco
print("[INFO] carregando reconhecedor facial...")
embedder = cv2.dnn.readNetFromTorch("/content/face-recognition-cnn/openface_nn4.small2.v1.t7")

# carrega o modelo real de reconhecimento facial junto com o codificador de rótulos
recognizer = pickle.loads(open("/content/drive/MyDrive/Colab Notebooks/FaceOpenCV/embeddingRecognizer2.pickle", "rb").read())
le = pickle.loads(open("/content/drive/MyDrive/Colab Notebooks/FaceOpenCV/le2.pickle", "rb").read())

# carrega a imagem, redimensiona-a para ter uma largura de 600 pixels (mantendo
# a proporção), e então obtém as dimensões da imagem
image = cv2.imread("/content/Miley-Cyrus-Def-Leppard.jpg")
image = imutils.resize(image, width=600)
(h, w) = image.shape[:2]

# constrói um blob a partir da imagem
imageBlob = cv2.dnn.blobFromImage(
    cv2.resize(image, (300, 300)), 1.0, (300, 300),
    (104.0, 177.0, 123.0), swapRB=False, crop=False)

# aplica o detector facial baseado em aprendizado profundo do OpenCV para localizar
# rostos na imagem de entrada
detector.setInput(imageBlob)
detections = detector.forward()

# loop sobre as detecções
for i in range(0, detections.shape[2]):
    # extrai a confiança (ou seja, probabilidade) associada à
    # previsão
    confidence = detections[0, 0, i, 2]

    # filtra detecções fracas
    if confidence > 0.55:

        # calcula as coordenadas (x, y) da caixa delimitadora para o
        # rosto
        box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
        (startX, startY, endX, endY) = box.astype("int")

        # extrai a região de interesse (ROI) do rosto
        face = image[startY:endY, startX:endX]
        (fH, fW) = face.shape[:2]

        # assegura que a largura e altura do rosto sejam suficientemente grandes
        if fW >= 20 and fH >= 20:

            # constrói um blob para a ROI do rosto, então passa o blob
            # através do nosso modelo de incorporação facial para obter a
            # quantificação de 128 dimensões do rosto
            faceBlob = cv2.dnn.blobFromImage(face, 1.0 / 255, (96, 96),
                                             (0, 0, 0), swapRB=True, crop=False)
            embedder.setInput(faceBlob)
            vec = embedder.forward()

            # realiza classificação para reconhecer o rosto
            preds = recognizer.predict_proba(vec)[0]
            j = np.argmax(preds)
            proba = preds[j]
            name = le.classes_[j]

            # desenha a caixa delimitadora do rosto junto com a
            # probabilidade associada
            text = "{}: {:.2f}%".format(name, proba * 100)
            y = startY - 10 if startY - 10 > 10 else startY + 10
            cv2.rectangle(image, (startX, startY), (endX, endY),
                          (0, 0, 255), 2)
            cv2.putText(image, text, (startX, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.45, (0, 0, 255), 2)

# mostra a imagem de saída
cv2_imshow(image)
cv2.waitKey(0)